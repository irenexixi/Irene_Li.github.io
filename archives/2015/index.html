
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2015 | qqli的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="qqli的技术博客">
<meta property="og:url" content="http://yoursite.com/archives/2015/">
<meta property="og:site_name" content="qqli的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qqli的技术博客">
<meta name="twitter:description">

  
    <link rel="alternative" href="/atom.xml" title="qqli的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">qqli的技术博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-http-2-url-resource" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/28/http-2-url-resource/" class="article-date">
  <time datetime="2015-10-28T08:05:20.000Z" itemprop="datePublished">Oct 28 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Http/">Http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/28/http-2-url-resource/">http-2-url&amp;resource</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>URL 就是因特网资源的标准化名称。URL 指向每一条电子信息， 告诉你它们位于何处，以及如何与之进行交互。</p>
<p>2.1 浏览因特网资源</p>
<p>URL 是浏览器寻找信息时所需的资源位置。</p>
<p>URI 是一类更通用的资源标识符， URL 实际上是它的一个子集.由两个主要的子集URL 和URN 构成。URL 是通过描述资源的位置来标识资源的，而URN则是通过名字来识别资源的，与它们当前所处位置无关。</p>
<p>目前应用程序处理的只是URI 的URL 子集。</p>
<p>URL分以下三部分:</p>
<p>• URL 的第一部分(http) 是URL方案(scheme) 。 方案可以告知Web 客户端怎样访问资源。在这个例子中. URL 说明要使用HTTP 协议。<br>• URL 的第二部分( www.joes-hardware.com )指的是服务器的位置.这部分告知Web 客户端资源位于何处.<br>• URL 的第三部分(/seasonal/index-fall.html)是资源路径。路径说明了请求的是服务器上哪个特定的本地资源。</p>
<p>方案://服务器位置/路径</p>
<p>图2-1 URL 是怎样与浏览器、客户端、服务器以及服务器文件系统中的位置进行关联的</p>
<p>URL 可以通过HTTP 之外的其他协议来访问资源。它们可以指向因特网上的任意资源，<br>比如个人的E-mail 账户: mailto:president@whitebouse.gov<br>比如通过文件传输协议(File Transfer Protocol), FTP) 才能获取的各种文件: ftp://ftp.lots-o-books.com/pub/complete-price-1ist.xls<br>从流视频服务器上下载电影: rtsp://www.joes-hardware.com:554/interview /cto_ video</p>
<p>2.2 URL的语法</p>
<p>大多数URL 方案的URL 语法都建立在这个由9 部分构成的通用格式上：</p>
<p><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></p>
<p>几乎没有哪个URL 中包含了所有这些组件. URL 最重要的3 个部分是方案(scheme) ，主机(host) 和路径(path) 。</p>
<p>表2-1 通用URL 组件</p>
<p>2.2.1 方案一一使用什么协议</p>
<p>方案名是大小写无关的</p>
<p>2.2.2 主机与端口</p>
<p>主机： 是哪台机器装载了资源（主机名www.joes-hardware.com/IP161.58.228.45 地址指向服务器）。<br>端口： 在那台机器的什么地方可以找到能对目标资源；（默认端口80）。</p>
<p>2.2.3 用户名和密码</p>
<p>FfP服务器就是这样一个常见的实例。</p>
<p>ftp://anonymous@ftp.prep.组.mit.edu/pub/gnu  显示了一个指定为anonymous 的用户名；<br>ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu  指定了用户名(anonymous) 和密码(my_passwd) ，两者之间由字符“:”分隔。</p>
<p>免费开源的FTP解决方案<a href="https://www.filezilla.cn/" target="_blank" rel="external">FileZilla</a></p>
<p>2.2.4 路径</p>
<p>URL 的路径组件说明了资源位于服务器的什么地方.路径通常很像一个分级的文件系统路径。字符”/“将HITP URL 的路径组件划分成一些路径段.每个路径段都有自己的参数(param) 组件.</p>
<p>2.2.5 参数</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/28/http-2-url-resource/" data-id="fl8anijypvyzjqey" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http-url-resource/">http-url&resource</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http-1-summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/27/http-1-summary/" class="article-date">
  <time datetime="2015-10-27T07:12:37.000Z" itemprop="datePublished">Oct 27 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Http/">Http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/http-1-summary/">http-1-summary</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.2 HTTP客户端有哪些？</p>
<p>万维网使用的网页浏览器(Web浏览器)、收寄电子邮件时的电子邮件客户端、以及即时通讯的客户端软件，如雨后春笋般出现的各种app也是客户端等.<br>命令行: HTTPie、cURL、Wget.</p>
<p>1.3 资源</p>
<p>Web 服 务 器 是 Web 资 源(Web resource) 的 宿 主。Web 资 源 是 Web 内 容 的 源 头。最简单的 Web 资源就是 Web 服务器文件系统中的静态文件。</p>
<p>图 1-2 所有能够提供 Web 内容的东西都是 Web 资源</p>
<p>1.3.1 媒体类型</p>
<p>因特网上有数千种数据类型，HTTP仔细地给每个通过Web传输的对象都打上名为MIME类型（MIME type）的数据格式标签。MIME（Multipurpose Internet Mail Extension，多用途因特网文件扩展）是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。</p>
<p>图1-3与数据内容一同回送的MIME类型</p>
<p>MIME 类型是一种文本标记,表示一种主要的对象类型和一个特定的子类型,中间由一条斜杠来分隔。</p>
<p>• HTML 格式的文本文档由 text/html 类型来标记。<br>• 普通的 ASCII 文本文档由 text/plain 类型来标记。（.txt文件）<br>• JPEG 版本的图片为 image/jpeg 类型。<br>• GIF 格式的图片为 image/gif 类型。<br>• Apple 的 QuickTime 电影为 video/quicktime 类型。<br>• 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。</p>
<p>1.3.1 URI</p>
<p>服务器资源名被称为统一资源标识符(Uniform Resource Identifier,URI),在世界范围内唯一标识并定位信息资源.</p>
<p>e.g. <a href="http://www.joes-hardware.com/specials/saw-blade.gif" target="_blank" rel="external">http://www.joes-hardware.com/specials/saw-blade.gif</a></p>
<p>URI 有两种形式,分别称为 URL 和 URN.</p>
<p>1.3.3 URL</p>
<p>统一资源定位符(URL)是资源标识符最常见的形式。</p>
<p>大部分 URL 都遵循一种标准格式,这种格式包含三个部分。<br>• URL 的第一部分被称为 方案(scheme),说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议(http://);<br>• 第二部分给出了服务器的因特网地址(比如,www.joes-hardware.com)<br>• 其余部分指定了 Web 服务器上的某个资源(比如,/specials/saw-blade.gif)</p>
<p>现在,几乎所有的 URI 都是 URL。</p>
<p>各种协议：<br>HTTP1.1(Hypertext Transfer Protocol Vertion 1.1)超文本传输协议-版本1.1。<br>FTP(File Transfer Protocol)文件传输协议<br>UDP(User Datagram Protocol)用户数据报协议<br>DHCP(Dynamic Host Configuration Protocol)动态主机配置协议<br>HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议<br>SMTP(Simple Mail Transfer Protocol)简单邮件传送协议<br>TCP/IP(Transmission Control Protocol/Internet Protocol)传输控制协议/Internet协议<br>TELNET Protocol虚拟终端协议<br>TFTP(Trivial File Transfer Protocol)小文件传输协议</p>
<p>Time Protocol时间协议<br>PPP(Point to Point Protocol)点对点协议<br>RIP(Routing Infomation Protocol)路由信息协议<br>POP3(Post Office Protocol Version 3)邮局协议-版本3<br>ICMP(Internet Control Message Protocol)Internet控制信息协议<br>IPv6(Internet Protocol Version 6)Internet协议-版本6</p>
<p>OSPF(Open Shortest Path First)开放最短路优先<br>ARP(Address Resolution Protocol)地址解析协议<br>SNMP(Simple Network Management P)网络管理协议<br>BGP4(Border Gateway Protocol Vertion 4)边界网关协议-版本4<br>HDLC(High-Level Data Link Control)高层数据链路协议</p>
<p>1.3.4 URN</p>
<p>URI 的第二种形式就是统一资源名(URN)。URN 是作为特定内容的唯一名称使用的,与目前的资源所在地无关。</p>
<p>urn:ietf:rfc:2141</p>
<p>1.4 事务</p>
<p>一个 HTTP 事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成。这种通信是通过名为 HTTP 报文(HTTP message)的格式化数据块进行的.</p>
<p>1.4.1 方法</p>
<p>HTTP 支持几种不同的请求命令,这些命令被称为 HTTP 方法(HTTP method)条 HTTP 请求报文都包含一个方法。这个方法会告诉服务器要执行什么动作(获取一个 Web 页面、运行一个网关程序、删除一个文件等)。</p>
<p>表1-2 一些常见的HTTP方法</p>
<p>HTTP方法     描  述<br>GET         从服务器向客户端发送命名资源<br>PUT         将来自客户端的数据存储到一个命名的服务器资源中去<br>DELETE      从服务器中删除命名资源<br>POST        将客户端数据发送到一个服务器网关应用程序<br>HEAD        仅发送命名资源响应中的 HTTP 首部</p>
<p>1.4.2 状态码</p>
<p>每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码,告知客户端请求是否成功,或者是否需要采取其他动作。</p>
<p>表1-3 一些常见的HTTP状态码</p>
<p>伴随着每个数字状态码,HTTP 还会发送一条解释性的“原因短语”文本。包含文本短语主要是为了进行描述,所有的处理过程使用的都是数字码。</p>
<p>HTTP 软件处理下列状态码和原因短语的方式是一样的。<br>200 OK<br>200 OK(from cache)</p>
<p>1.4.3 Web页面中可以包含多个对象</p>
<p>应用程序完成一项任务时通常会发布多个 HTTP 事务。</p>
<p>1.5 报文</p>
<p>HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文都是纯文本,不是二进制代码,所以人们可以很方便地对其进行读写.</p>
<p>从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文(request message) 。从服务器发往客户端的报文称为响应报文(response message) ,此外没有其他类型的 HTTP 报文。</p>
<p>HTTP 报文包括以下三个部分。</p>
<p>• 起始行<br>• 首部字段<br>• 主体</p>
<p>1.6 连接</p>
<p>1.6.1 TCP/IP</p>
<p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节;它把联网的细节都交给了通用、可靠的因特网传输协议 TCP/IP。</p>
<p>TCP 提供了:<br>• 无差错的数据传输;<br>• 按序传输(数据总是会按照发送的顺序到达)。<br>• 未分段的数据流(可以在任意时刻以任意尺寸将数据发送出去)</p>
<p>图1-9 HTTP网络协议栈</p>
<p>在 HTTP 客户端向服务器发送报文之前,需要用网际协议(Internet Protocol,IP)地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。</p>
<p>建立一条 TCP 连接的过程与给公司办公室的某个人打电话的过程类似。首先,要拨打公司的电话号码。这样就能进入正确的机构了。其次,拨打要联系的那个人的分机号。</p>
<p>在 TCP 中,你需要知道服务器的 IP 地址,以及与服务器上运行的特定软件相关的TCP 端口号。</p>
<p><a href="http://207.200.83.29:80/index.html" target="_blank" rel="external">http://207.200.83.29:80/index.html</a><br><a href="http://www.netscape.com:80/index.html" target="_blank" rel="external">http://www.netscape.com:80/index.html</a><br><a href="http://www.netscape.com/index.html" target="_blank" rel="external">http://www.netscape.com/index.html</a><br>第一个 URL 使用了机器的 IP 地址,207.200.83.29 以及端口号 80。<br>第二个 URL 没有使用数字形式的 IP 地址,它使用的是文本形式的域名,或者称为主机名(www.netscape.com)。主机名就是 IP 地址比较人性化的别称。可以通过一种称为域名服务(Domain Name Service,DNS)的机制方便地将主机名转换为 IP地址,这样所有问题就都解决了。<br>最后一个 URL 没有端口号。HTTP 的 URL 中没有端口号时,可以假设默认端口号是 80。</p>
<p>图 1-10 基本的浏览器连接处理<br>步骤如下:<br>(a) 浏览器从 URL 中解析出服务器的主机名;<br>(b) 浏览器将服务器的主机名转换成服务器的 IP 地址;<br>(c) 浏览器将端口号(如果有的话)从 URL 中解析出来;<br>(d) 浏览器建立一条与 Web 服务器的 TCP 连接;<br>(e) 浏览器向服务器发送一条 HTTP 请求报文;<br>(f) 服务器向浏览器回送一条 HTTP 响应报文;<br>(g) 关闭连接,浏览器显示文档。</p>
<p>1.6.3 使用Telnet实例</p>
<p>% telnet www.joes-hardware.com 80<br>Trying 161.58.228.45…<br>Connected to joes-hardware.com.<br>Escape character is ‘^]’.<br>GET /tools.html HTTP/1.1<br>Host: www.joes-hardware.com</p>
<p>1.7 协议版本</p>
<p>• HTTP/0.9<br>HTTP 的 1991 原型版本称为 HTTP/0.9。这个协议有很多严重的设计缺陷,只应该用于与老客户端的交互。HTTP/0.9 只支持 GET 方法,不支持多媒体内容的MIME 类型、各种 HTTP 首部,或者版本号。HTTP/0.9 定义的初衷是为了获取简单的 HTML 对象,它很快就被 HTTP/1.0 取代了。</p>
<p>• HTTP/1.0<br>1.0 是第一个得到广泛使用的 HTTP 版本。HTTP/1.0 添加了版本号、各种 HTTP首部、一些额外的方法,以及对多媒体对象的处理。</p>
<p>• HTTP/1.0+<br>在 20 世纪 90 年代中叶,很多流行的 Web 客户端和服务器都在飞快地向 HTTP中添加各种特性,以满足快速扩张且在商业上十分成功的万维网的需要。并成为非官方的事实标准,这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+。</p>
<p>• HTTP/1.1<br>HTTP/1.1 重点关注的是校正 HTTP 设计中的结构性缺陷,明确语义,引入重要的性能优化措施,并删除一些不好的特性。HTTP/1.1 还包含了对 20 世纪 90 年代末正在发展中的更复杂的 Web 应用程序和部署方式的支持。HTTP/1.1 是当前使用的 HTTP 版本。</p>
<p>• HTTP-NG(又名 HTTP/2.0)<br>HTTP-NG 是 HTTP/1.1 后继结构的原型建议,它重点关注的是性能的大幅优化,以及更强大的服务逻辑远程执行框架。</p>
<p>1.8 Web的结构组件</p>
<p>• 代理<br>位于客户端和服务器之间的 HTTP 中间实体。<br>• 缓存<br>HTTP 的仓库,使常用页面的副本可以保存在离客户端更近的地方。<br>• 网关<br>连接其他应用程序的特殊 Web 服务器。<br>• 隧道<br>对 HTTP 通信报文进行盲转发的特殊代理。<br>• Agent 代理<br>发起自动 HTTP 请求的半智能 Web 客户端。</p>
<p>1.8.1 代理</p>
<p>图 1-11 在客户端和服务器之间转发流量的代理</p>
<p>代理位于客户端和服务器之间,接收所有客户端的 HTTP 请求,并将这些请求转发给服务器(可能会对请求进行修改之后转发)。对用户来说,这些应用程序就是一个代理,代表用户访问服务器。</p>
<p>1.8.2 缓存</p>
<p>Web 缓存(Web cache)或代理缓存(proxy cache)是一种特殊的 HTTP 代理服务器,可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了</p>
<p>1.8.3 网关</p>
<p>网关(gateway)是一种特殊的服务器,作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<p>1.8.4 隧道</p>
<p>隧道(tunnel)是建立起来之后,就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据,转发时不会窥探数据。</p>
<p>图 1-14 隧道可以在非 HTTP 网络上转发数据(显示的是 HTTP/SSL 隧道)</p>
<p>1.8.5 Agent代理</p>
<p>用户 Agent 代理(或者简称为 Agent 代理)是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止,我们只提到过一种 HTTP Agent 代理:Web 浏览器,但用户 Agent 代理还有很多其他类型。</p>
<p>自动代理的名字通常都很生动,比如“网络蜘蛛”(spiders)或者“Web 机器人”(Web robots)。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/27/http-1-summary/" data-id="tof1tcbk66ms7j94" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http-summary/">http-summary</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-11-regexp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/26/essence-11-regexp/" class="article-date">
  <time datetime="2015-10-26T09:48:30.000Z" itemprop="datePublished">Oct 26 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/26/essence-11-regexp/">essence-11-Regexp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— 正则表达式</p>
<p>正则表达式是一门简单语言的语法规范。它以方法的形式被用于对字符串中的信息进行查找、替换和提取的操作。可处理正则表达式的方法有regexp.exec, regexp.test，string.match, string.replace, string.search &amp; string.split.通常来说，在JavaScript中正则表达式相较于等效的字符串运算有显著的性能优势。</p>
<p>正则表达式起源于对形式语言的数学研究。Ken Thompson基于Stephen对type-3语言的理论研究写出了一个切实可用的模式匹配器，它能够被嵌入到编程语言和像文本编辑器这样的工具中。</p>
<p>在JavaScript中，正则表达式的语法是对Perl版的改进和发展，它非常接近源自贝尔实验室的原始形式。正则表达式的书写规则出奇地复杂，因为他们把某些地方的字符串解析为运算符。而把仅在位置上稍微不同的相同字符串当作字面量。比不易书写更糟糕的是，这使得正则表达式不仅难以阅读，而且修改时充满危险。要想正确的阅读他们，就必须对正则表达式的整个复杂性有相当彻底的理解。</p>
<p>现在的正则表达式的规则并不总是严格的，但它们非常有用。正则表达式趋向于极致的简洁，甚至不惜容忍含义的模糊。在最简单的形势下，他们是易于使用的，但优点让人感到费解。正则表达式难以分段阅读，因为它们不支持注释和空白。它的所有部分都被紧密排在一起，使得它们几乎无法被辨认。当它们在安全应用中进行扫描和验证时，这点就需要被特别的留意。</p>
<p><strong>1、e.g. 一个用来匹配URl的正则表达式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/{<span class="number">0</span>,<span class="number">3</span>})([<span class="number">0</span>-<span class="number">9</span>.\-A-Za-z]+)(?::(\d+))?(?:\/([^?<span class="comment">#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</span></div><div class="line">var url = <span class="string">"http://www.ora.com:80/googleparts?q#fragment"</span>;</div><div class="line"></div><div class="line">var result = parse_url.exec(url);</div><div class="line">var names = [<span class="string">'url'</span>, <span class="string">'scheme'</span>, <span class="string">'slash'</span>, <span class="string">'host'</span>, <span class="string">'port'</span>, <span class="string">'path'</span>, <span class="string">'query'</span>, <span class="string">'hash'</span>];</div><div class="line">var blanks = <span class="string">''</span>;</div><div class="line">var i;</div><div class="line">console.log(result);</div><div class="line">//[<span class="string">"http://www.ora.com:80/googleparts?q#fragment"</span>, <span class="string">"http"</span>, <span class="string">"//"</span>, <span class="string">"www.ora.com"</span>, <span class="string">"80"</span>, <span class="string">"googleparts"</span>, <span class="string">"q"</span>, <span class="string">"fragment"</span>, index: <span class="number">0</span>, input: <span class="string">"http://www.ora.com:80/googleparts?q#fragment"</span>]</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; names.length; i++) {</div><div class="line">    console.log(names[i] + <span class="string">':'</span> + blanks.substring(name[i].length), result[i]);</div><div class="line">}</div></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/26/essence-11-regexp/" data-id="svtqed1j6nkrs795" class="article-share-link" data-share="baidu">Share</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-essence-10-JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/21/essence-10-JSON/" class="article-date">
  <time datetime="2015-10-21T09:45:37.000Z" itemprop="datePublished">Oct 21 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/21/essence-10-JSON/">essence-10-JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— JSON</p>
<p>JavaScript对象表示法（JavaScript Object Notation，简称JSON），是一种轻量记得数据交换格式。它基于JavaScript的对象字面量表示法，那是JavaScript最精华的部分之一。</p>
<p>尽管是JavaScript的一个子集，但它与语言无关。它可以被用在所有以现代编程语言编写的程序之间交换数据。它是一种文本格式，所以可以被人和机器阅读。</p>
<p><strong>1、JSON语法</strong></p>
<p>JSON有6种类型的值：对象，数组、字符串，数字、布尔值（true &amp; false）、特殊值null。空白（空格、制表符、回车符&amp;换行符）可被插到任何值的前后。这使得JSON文本更容易阅读。为了减少传输和存储的成本，空白可以被省略。</p>
<p>JSON对象是一个容纳‘名/值’对的无序集合。名字可以是任何字符串。值可以是任何类型的JSON值，包括数组和对象。JSON对象可以被无限层的嵌套。但一般来说保持结构的扁平是最高效的。大多数语言都有容易被映射为JSON对象的数据类型，比如对象（object）、结构（struct）、字典（dictionary）、哈希表（hash table）、属性列表或关联数组。</p>
<p>JSON数组是一个值的有序序列。其值可以是任何类型JSON值，包括数组和对象。大多数语言都有容易被映射为JSON数组的数据类型，比如数组、向量（vector）、列表（list）或序列（sequence）。</p>
<p>JSON字符串要被包围在一对双引号之间。\字符被用于转义。JSON允许/字符被转义，所以JSON可以嵌入HTML的Script标签之中。除非用标签初始化，否则HTML不允许使用&lt;/字符序列。但JSON允许使用&lt;\/，它能产生同样的结果却不会与HTML相混淆。</p>
<p>JSON数字与JavaScript数字相似。整数的首位不允许为0，因为一些语言用它来标识八进制。这种基数的混乱在数据交换格式中是不可取的。数字可以是整数、实数或科学计数。</p>
<p><strong>2、安全的使用JSON</strong></p>
<p>JSON特别易于用在Web应用中，因为JSON就是JavaScript。使用eval函数可以把一段JSON文本转换成一个有用的数据结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myData = <span class="built_in">eval</span>(<span class="string">'('</span>+ myJSONText +<span class="string">')'</span>);</div></pre></td></tr></table></figure>

<p>用圆括号把JSON文本括起来是一种避免JavaScript语法中的歧义的变通方案。然后，eval函数有着骇人的安全问题。</p>
<p>目前，在web浏览器中从服务端获取数据的最佳技术是XMLHttpRequest。XMLHttpRequest成html的同一服务器获取数据。使用eval解析来自那个服务器的文本安全性和解析最初HTML的安全性一样低。</p>
<p>有漏洞的服务器或许并不能正确的对JSON进行编码。如果它通过拼凑一些字符串而不是使用一个合适的JSON编码器来创建JSON文本，那么它可能在无意间发送危险的数据。如果它充当的是代理的角色，并且尚未确定JSON文本是否格式良好就简单的传递它，那么它可能再次的发送危险数据。</p>
<p>使用JSON.parse方法替代eval就能避免这种危险。如果文本中包含任何危险数据，那么JSON.parse将抛出一个异常。为了防止服务器出现漏洞的情况，总是用JSON.parse来替代eval，即使有一天浏览器提供了连到其他服务器的安全数据访问，使用它同样是个很好的习惯。</p>
<p>在外部数据与innerHTML进行交互时还存在另外一种危险。一种常见的Ajax模式是把服务器端发送过来的一个HTML文本片段赋值给某个HTML元素的innerHTML属性。这是一个非常糟糕的习惯。如果这个HTML片段包括一个<script>标签或其等价物，那么恶意脚本将会被运行。这可能又是因为服务端存在漏洞。</p>
<p>具体有什么危险呢？如果一个恶意脚本在你的网页上被运行，它就有权访问这个页面的所有状态和该页面能做的操作。它能与你的服务器进行交互，而你的服务器将不能区分正当请求和恶意请求。恶意的脚本还能访问全局对象，这使得他有权限访问该应用中除隐藏于闭包中的变量之外的所有数据。它可以访问document对象，这会使它有权访问用户所能看到的一切。它还给这个恶意脚本提供了与用户进行会话的能力。浏览器的地址栏和所有的反钓鱼程序将告诉用户这个会话是可靠的。document对象还给该恶意脚本授权访问网络，允许它去下载更多的恶意脚本，或者是在你的防火墙之内探测站点，或者将它已窃取的隐私内容发送给世界的任何一台服务器。</p>
<p>这个危险是JavaScript全局变量的直接后果，它是JavaScript众多糟粕中最糟糕的一个。这些危险并不是由Ajax、JSON、XMLHttpRequest或web2.0导致的。</p>
</script></p>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/21/essence-10-JSON/" data-id="c7o7px2utcuqd0rg" class="article-share-link" data-share="baidu">Share</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-essence-6-code-style" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/19/essence-6-code-style/" class="article-date">
  <time datetime="2015-10-19T07:14:01.000Z" itemprop="datePublished">Oct 19 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/essence-6-code-style/">essence-code-style</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— 代码风格</p>
<p><strong>1. 为什么要讲代码风格</strong></p>
<p>优秀的程序拥有一个前瞻性的结构，它会预见到在未来才可能需要的修改，但不会让其成为过度的负担。优秀的程序还会具备一种清晰的表达式，如果一个程序被表达得很好，那么我们就能更加清晰的去理解它，以便成功的修补或改造它。</p>
<p>上面的观点适合所有的编程语言，而对Javascript来说尤为如此。Javascript的弱类型和过度的容错性导致程序质量无法在编译时获得保障，所以为了弥补，我们更应该按照严格的规范进行编码。</p>
<p>对于一个组织机构来说，软件的长远价值和代码库质量成正比。在程序的生命周期里，会经过很多人的测试、使用、修改。如果一个程序能很清除的传达它的结构和特性，那么当它在并不遥远的将来被修改时，它被破坏的可能性就小很多。</p>
<p>如果程序可读性强，它正常运行的可能性，以及是否准确按照我们的意图去工作的可能性也显著增强。它还决定了程序在其生命周期中是否可扩展。</p>
<p><strong>2. 代码风格</strong></p>
<p><strong>使用一致的留白来帮助理解程序的逻辑思路</strong></p>
<p>a. 代码快内容和对象字面量缩进4个空格<br>b. 放1个空格在if和（**, 以致if不会看起来像是函数调用，只有真的是在调用时，才使用（与前面的符号相毗连.<br>c. 在除了。和 [之外的所有运算符的两边都放了空格,他们两无需空格是因为他们有更高的优先级。<br>d. 每个逗号和冒号的后面都使用一个空格。<br>e. 在每行最多放一条语句，在一行里放多条语句可能会被误读。如果一条语句放不完，可以在冒火或二元运算符后拆开它。可以防止自动插入分号的机制掩盖复制/粘贴的错误。给折断后的其余语句多缩进4个空格。<br>f. 在if和while这样的结构化的语句里，始终使用代码块的方式，这样会减少出错的几率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> （a）</div><div class="line">    b();</div></pre></td></tr></table></figure>


<p>变成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> （a）</div><div class="line">    b();</div><div class="line">    c();</div></pre></td></tr></table></figure>

<p>这是一个很难发现的错误，看起来像是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> （a）{</div><div class="line">    b();</div><div class="line">    c();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而实际上是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> （a）{</div><div class="line">    b();</div><div class="line">}</div><div class="line"> c();</div></pre></td></tr></table></figure>

<p>这种情况下，很可能会导致bug，一对花括号可以用很低廉的成本去防止那些需要昂贵的代价才能发现的bug。</p>
<p>g. 把{放在一行的结尾，而不是下一行的开头。这样做可以避免return语句中的一个可怕的设计错误。<br>h. 努力保持注释是最新的，错误的注释甚至可能会使程序更加难以阅读和理解。有时候觉得注释就像时间机器，我用它发送重要的信息给未来的我。（作者的比喻实在是太好）在Js里，我更喜欢用行注释。把块注释用于正式的文档记录和注释。</p>
<p>尽量不写无用的注释。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>; //设置i为<span class="number">0</span></div></pre></td></tr></table></figure>

<p>i. Javascript有作用域，但没有块级作用域，所以在函数开头声明所有变量。</p>
<p>作者： 对于一个脚本应用或工具库，我只用唯一一个全局变量。每个对象都有它自己的命名空间，所以我很容易使用对象去管理代码。使用闭包能提供进一步的信息隐藏，增强我的模块的健壮性。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/19/essence-6-code-style/" data-id="uof5eti9wmuktobo" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-code-style/">essence-code-style</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-7-graceful-characteristic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/19/essence-7-graceful-characteristic/" class="article-date">
  <time datetime="2015-10-19T07:14:01.000Z" itemprop="datePublished">Oct 19 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/essence-7-graceful-characteristic/">essence-graceful-characteristic</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— 优美的特性</p>
<p><strong>精简的Javascript里都是好东西，包括以下内容：</strong></p>
<p><strong>1. 函数是顶级对象</strong></p>
<p>在精简的Javascript中，函数是有词法作用域的闭包。</p>
<p><strong>2. 基于原型继承的动态对象</strong></p>
<p>对象是无类别的。我们可以通过普通的赋值给任何对象增加一个新成员属性。一个对象可以从另一个对象继承成员属性。</p>
<p><strong>3. 对象字面量和数组字面量</strong></p>
<p>这对创建新的对象和数组来说是一种非常方便的表示法，Javascript字面量是数据交换格式JSON的灵感之源。</p>
<p><strong>事实证明，做出恰好可以工作的设计比做出集合一大串特性的设计要困难得多</strong></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/19/essence-7-graceful-characteristic/" data-id="2ost4lapug7crtc6" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-graceful-characteristic/">essence-graceful-characteristic</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-8-loose" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/19/essence-8-loose/" class="article-date">
  <time datetime="2015-10-19T07:14:01.000Z" itemprop="datePublished">Oct 19 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/essence-8-loose/">essence-loose</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— 毒瘤</p>
<p><strong>以下是Javascript中一些难以避免的问题特性，必须知道这些问题并准备好应对的措施</strong></p>
<p><strong>1. 全局变量</strong></p>
<p>在Javascript所有最糟糕的特性之中，最为糟糕的一个特性就是它对全局变量的依赖。全局变量是在所有作用域中可见的变量。在微型程序中可能会带来很多方便，但随着程序越来越复杂，它们很快就变得难以管理。在程序中使用全局变量降低了程序的可靠性。</p>
<p>全局变量使得在同一个程序中运行独立的子程序变得更难。如果有些全局变量的名称恰巧和子程序的变量名相同，那么他们将会发生冲突，可能导致程序无法运行，而且通常难以调试。</p>
<p>定义全局变量的3种方法：</p>
<p>a. 在任何函数之外放置一个var语句；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var foo = value;</div></pre></td></tr></table></figure>

<p>b. 直接给全局对象加一个属性，全局对象是所有全局变量的容器；在web浏览器里全局对象是window。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.foo = value;</div></pre></td></tr></table></figure>

<p>c. 直接使用未经声明的变量。这被称为隐式的全局变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = value;</div></pre></td></tr></table></figure>

<p><strong>2. 作用域</strong></p>
<p>Javascript采用了块语法，却没有提供块级作用域：代码块中声明的变量在包含此代码块的函数的任何位置都是可见的。</p>
<p>一般来说，声明变量的最好的地方是在第一次用到它的地方。但这种做法在Javascript里面反而是一种坏习惯，因为它没有块级作用域。更好的方式是在每个函数的开头部分声明所有的变量。</p>
<p><strong>3. 自动插入分号</strong></p>
<p>Javascript有一个自动修复机制，它试图通过自动插入分号来修正有缺损的程序。但千万别指望它，它可能会带来更严重、更可怕的错误。</p>
<p>有时他会不合适宜的插入分号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> </div><div class="line">{</div><div class="line">    status: <span class="literal">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>本意是要返回一个包含status属性的对象，遗憾的是，自动插入分号让它变成了返回undefined。自动插入分号会导致程序被误解，却没有任何警告提醒。只要把{放在一行的尾部而不是下一含的开头就可以避免该问题了。</p>
<p><strong>4. 保留字</strong></p>
<p>下面的单词在JavaScript里被保留：</p>
<p>abstract boolean break byte case catch char class const continue debugger default delete do double else enum<br>export false final finally float for function goto if implement import in instanceof int interface long native<br>new null package private protected public return short static super switch synchronized this throw throws transient<br>true try typeof var volatile void while with</p>
<p>这些单词中的大部分并没有在Javascript中使用。</p>
<p>它们不能被用来命名参数或变量。当保留字被用做对象字面量的键值时，它必须被引号括起来。他们不能被用在点表示法中，所以有时必须使用括号表示法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var method; //ok</div><div class="line">var class;  //error</div><div class="line">object = { box: value }; //ok</div><div class="line">object = { <span class="keyword">case</span>: value } //非法</div><div class="line">object = { <span class="string">'case'</span>: value } //ok</div><div class="line">object.box = value; //ok</div><div class="line">object.case = value; //非法</div><div class="line">object[<span class="string">'case'</span>] = value; //ok</div></pre></td></tr></table></figure>

<p><strong>5. Unicode（没明白）</strong></p>
<p>JavaScript设计之初，Unicode预期最多会有65536个字符。但从那以后它的容量慢慢增长到拥有一百万个字符。</p>
<p>JavaScript的字符是16位的，足以覆盖原有的65536个字符（现被称为基本多文种平面）剩下的百万字符中的每一个都可以用一对字符来表示。Unicode把一对字符视为一个单一的字符。而JavaScript认为一对字符是两个不同的字符。</p>
<p><strong>6. typeof</strong></p>
<p>typeof运算符返回一个用于识别其运算数类型的字符串。所以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof <span class="number">98.6</span>  //<span class="string">"number"</span></div></pre></td></tr></table></figure>

<p>遗憾的是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof null  //<span class="string">"object"</span>, 不是“null”; 有个更简单也更好检测null的方式：my_value === null;(没懂)</div></pre></td></tr></table></figure>

<p>一个更大的问题是检测对象的值。typeof不能辨别出null与对象，但你可以像下面这样做，因为null值为假，而所有对象值为真：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var my_value = {};</div><div class="line"><span class="keyword">if</span> (my_value && typeof my_value === <span class="string">'object'</span>) {</div><div class="line">    console.log(<span class="string">'object'</span>);  //object</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在对正则表达式的类型识别上，各种JavaScript的实现不太一致。对于下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof /a/  //chrome下， <span class="string">"object"</span></div></pre></td></tr></table></figure>

<p>一些实现会返回‘object’，而其他的返回‘function’。如果返回‘regexp’可能会更有用些，但标准不允许这样做。</p>
<p><strong>7. parseInt</strong></p>
<p>parseInt是一个把字符串转换成为整数的函数。它在遇到非数字时会被停止解析，所以parseInt(“16”)与parseInt(“16 tons”)产生相同的结果。如果该函数会提醒我们出现了额外文本就好了，但它不会这么做。</p>
<p>如果该字符串第一个字符是0，那么该字符串会基于八进制二不是十进制来求值。在八进制中，8和9不是数组，所以parseInt(“08”)和parseIny(“09”)都产生0作为结果。这个错误会导致程序解析日期和时间出现问题。幸运的是，parseInt可以接收一个基数作为参数，如此一来parseInt(“08”)的结果是8。建议总是加上这个基本参数。</p>
<p><strong>8. +</strong></p>
<p>+运算符可以用于加法运算符或字符串连接。它究竟会如何执行取决于其参数的类型。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。</p>
<p>如果两个运算数都是数字，它返回两者之和，否则，它把两个运算数都转换成字符串并连接起来。这个复杂的行为是bug的常见来源。如果你打算用+去坐加法运算，请确保两个运算数都是整数。</p>
<p><strong>9. 浮点数</strong></p>
<p>二进制的浮点数不能正确的处理十进制的小数。因此0.1+0.2不等于0.3，这是JavaScript中经常报的bug，并且它是遵循二进制浮点数算数标准而有意导致的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span>+<span class="number">0.2</span>     //<span class="number">0.30000000000000004</span></div><div class="line"><span class="number">1.1</span>+<span class="number">2.3</span>     //<span class="number">3.4</span></div></pre></td></tr></table></figure>

<p>幸运的是浮点数中的整数是精确的，所以小数表现的错误可以通过指定精度来避免。</p>
<p>e.g. 美元可以通过乘以100转换成美分，然后就可以准确的将美分相加。他们的和可以除以100转换成美元。</p>
<p><strong>10. NaN</strong></p>
<p>NaN是IEEE754中定义的一个特殊的数量值。它表示不是一个数字，尽管下面的表达式返回的是true：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof NaN === <span class="string">'number'</span>;  //<span class="literal">true</span></div></pre></td></tr></table></figure>

<p>Null可能会在试图将非数字形式的字符串转换为数字时产生。e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ <span class="string">'0'</span>;     //<span class="number">0</span></div><div class="line">+ <span class="string">'oops'</span>;  //NaN</div></pre></td></tr></table></figure>

<p>如果NaN是数学运算中的一个运算数，那么结果回事NaN。所以，如果一个公式链产生出NaN结果，那么至少有一个输入项是NaN，或者在某个地方产生了NaN。</p>
<p>你可以对NaN进行检测，正如我们之前所见，typeof并不能辨别数字和NaN，并且事实NaN不等于它自己，令人惊讶：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NaN === NaN;  //<span class="literal">false</span></div><div class="line">NaN !== NaN;  //<span class="literal">true</span></div></pre></td></tr></table></figure>

<p>JavaScript提供了一个isNaN函数可以辨识数字和NaN。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isNaN(NaN);      //<span class="literal">true</span></div><div class="line">isNaN(<span class="number">0</span>);        //<span class="literal">false</span></div><div class="line">isNaN(<span class="string">'oops'</span>);   //<span class="literal">true</span></div></pre></td></tr></table></figure>

<p>判断一个值是否可以做数字的最佳方法是使用isFinite函数，因为它会筛除掉NaN和Infinity。不幸的是，isFinite会视图把它的运算数转换成一个数字，如果值事实上不是一个数字，它就不是一个好的测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function isNumber(value){</div><div class="line">    <span class="keyword">return</span> typeof value === <span class="string">'number'</span> && isFinite(value);</div><div class="line">}</div><div class="line">isNumber(<span class="number">1</span>);      //<span class="literal">true</span></div><div class="line">isNumber(<span class="string">'oops'</span>); //<span class="literal">false</span></div></pre></td></tr></table></figure>

<p><strong>11. 伪数组</strong></p>
<p>JavaScript没有真正的数组。这也不全是坏事，JavaScript数组很容易使用。不必给他们设置维度，永远不用担心会出现越界错误。但他们的性能相比真正的数组可能相当糟糕。</p>
<p>typeof运算符不能识别数组和对象。要判断一个值是否为数组，还必须要检查它的constructor属性:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var my_value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">if</span>(my_value && typeof my_value === <span class="string">'object'</span> && my_value.constructor === Array){</div><div class="line">    //my_value是一个数组</div><div class="line">    console.log(<span class="string">'array'</span>); //array</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的检测对于在不同帧或窗口创建的数组会给出false，当数组有可能在其他帧中被创建时，下面的检测更可靠：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var my_value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">if</span>(my_value && typeof my_value === <span class="string">'object'</span> && typeof my_value.length === <span class="string">'number'</span> && !(my_value.propertyIsEnumerable(<span class="string">'length'</span>))){</div><div class="line">    //my_value是一个数组</div><div class="line">    console.log(<span class="string">'array'</span>); //array</div><div class="line">}</div></pre></td></tr></table></figure>

<p>arguments数组不是一个数组，它是一个带有length成员元素的对象。上面的检测方法会将arguments识别成一个数组。</p>
<p><strong>12. 假值</strong></p>
<p>JavaScript拥有一大组令人惊讶的假值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">值             类型</div><div class="line"><span class="number">0</span>              Number</div><div class="line">NaN（非数字）   Number</div><div class="line"><span class="string">' '</span>（空字符串） String</div><div class="line"><span class="literal">false</span>         Boolean</div><div class="line">null          Object</div><div class="line">undefined     Undefined</div></pre></td></tr></table></figure>

<p>这些值全都等同于假，但他们是不可互换的，e.g.这是一种错误的方式去确定一个对象是否缺少一个成员元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var value = myObject[name];</div><div class="line"><span class="keyword">if</span> (value == null){</div><div class="line">    alert(value + <span class="string">" not found"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>undefiend是缺失的成员元素的值</p>
<p><strong>13. hasOwnProperty</strong></p>
<p>hasOwnProperty方法被用做一个过滤器去避开for in语句的遍历。不幸的是，hasOwnProperty是一个方法，不是一个运算符，所以在任何对象中，它可能会被一个不同的函数甚至一个非法函数的值所替换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name;</div><div class="line">another_stooge.hasOwnProperty = null;  //地雷</div><div class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> another_stooge){ </div><div class="line">    <span class="keyword">if</span> (another_stooge.hasOwnProperty(name)) { //触雷</div><div class="line">        document.write(name + <span class="string">": "</span> + another_stooge[name]);    </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>14. 对象</strong></p>
<p>JavaScript的对象永远不会有真的空对象，因为它可以从原型链对象中取得成员元素。有时候这会带来一些麻烦。</p>
<p>e.g.假设你正在编写一个程序去计算一段文本中每个单词出现的次数。我们可以利用toLowerCase方法统一转换文本为小写格式，并接着使用split方法以一个正在表达式为参数去产生出一个单词数组。然后可以遍历该数组单词并计算我们看到的每一个单词的次数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var i;</div><div class="line">var word;</div><div class="line">var text = <span class="string">"This oracle of comfort has no pleased me, That when I am in heaven I shall desire to see what this child dose, and praise my Constructor"</span>;</div><div class="line"></div><div class="line">var words = text.toLowerCase( ).split(/[\s,.]+/);</div><div class="line">var count = {};</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; words.length; i++){</div><div class="line">    word = words[i];</div><div class="line">    <span class="keyword">if</span> (count[word]) {</div><div class="line">        count[word] += <span class="number">1</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        count[word] = <span class="number">1</span>;</div><div class="line">    }</div><div class="line">} //count输出Object {this: <span class="number">2</span>, oracle: <span class="number">1</span>, of: <span class="number">1</span>, comfort: <span class="number">1</span>, has: <span class="number">1</span>…}</div></pre></td></tr></table></figure>

<p>让我们来研究结果，count[‘this’]的值为2，count.heavy的值是1，但是count.constructor却包含着一个令人不可思议的字符串（constructor: “function Object() { [native code] }1”）。其原因在于，count对象继承自Object.property，而Object.property包含着一个名为constructor的成员对象，它的值是一个Object。因为该对象是一个函数，所以+=运算符将其转换成一个奇怪的字符串，然后再把1个数字1加在它的后面。</p>
<p>我们可以这样来避免：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (typeof count[word] === <span class="string">'number'</span>) { }</div></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/19/essence-8-loose/" data-id="to1jbpgnqwv3e6b6" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-loose/">essence-loose</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-9-chicken-ribs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/19/essence-9-chicken-ribs/" class="article-date">
  <time datetime="2015-10-19T07:14:01.000Z" itemprop="datePublished">Oct 19 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/essence-9-chicken-ribs/">essence-chicken-ribs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 —— 鸡肋</p>
<p><strong>以下是Javascript中一些有问题的特性，我们能够很容易就避免它们。通过这些简单的做法，就可以使JavaScript成为一门更好的语言，也能让你成为一个更好的程序员</strong></p>
<p><strong>1. ==</strong></p>
<p>JavaScript有两组相等运算符：=== &amp; !==，以及他们邪恶的孪生兄弟== &amp; !=.   === &amp; ！== 这一组运算符会按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么===返回true，而!==返回false。</p>
<p>而==&amp;!=只有在两个运算数类型一致时才会做出正确判断，但如果两个运算数类型不同时，它们试图强制转换其值的类型。转换的规则复杂且难以记忆。e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">''</span> == <span class="string">'0'</span>;  //<span class="literal">false</span></div><div class="line"><span class="number">0</span> == <span class="string">''</span>;    //<span class="literal">true</span></div><div class="line"><span class="number">0</span> == <span class="string">'0'</span>;   //<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="literal">false</span> == <span class="string">'false'</span>;  //<span class="literal">false</span></div><div class="line"><span class="literal">false</span> == <span class="string">'0'</span>;      //<span class="literal">true</span></div><div class="line"><span class="literal">false</span> == <span class="number">0</span>;        //<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="literal">false</span> == undefined;  //<span class="literal">false</span></div><div class="line"><span class="literal">false</span> == null;       //<span class="literal">false</span></div><div class="line">undefined == null;   //<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="string">'\t\r\n'</span> == <span class="number">0</span>;    //<span class="literal">true</span></div></pre></td></tr></table></figure>

<p>==运算符对传递性的缺乏值得我们警惕。建议不要使用==&amp;!=运算符，如果以上的比较使用===，均返回false。</p>
<p><strong>2. with语句</strong></p>
<p>JavaScript提供了一个with语句，本意是想用来快捷的访问对象的属性，不幸的是，它的结果有时是不可预料的，应该避免使用。e.g.</p>
<p>下面的语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with(obj){</div><div class="line">    a = b;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和下面的代码做着同样的事情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (obj.a === undefined){</div><div class="line">    a = obj.b === undefined ? b : obj.b;</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    obj.a = obj.b === undefined ? b : obj.b;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以，它等于这些语句中的任何1条。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = b;</div><div class="line">a = obj.b;</div><div class="line">obj.a = b;</div><div class="line">obj.a = obj.b;</div></pre></td></tr></table></figure>

<p>通过阅读程序代码，你不可能辨别出你会得到这些语句中的哪一句。它可能随着程序运行到下一步时发生变化。它甚至可能在程序运行过程就发生变化了。</p>
<p>with语句在该门语言中存在，本身就严重影响了JavaScript处理器的速度，因为它阻止了变量名的词法作用域的绑定。它的本意是好的，但如果没有它，JavaScript会更好一些。</p>
<p><strong>3. eval</strong></p>
<p>eval函数传递一个字符串给JavaScript编译器，并且执行其结果。它是被滥用得最多的JavaScript特性，那些对JavaScript一知半解的人们最常用他们。</p>
<p>e.g. 如果你知道点表示法，不知道下标表示法，就可能会这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"myValue = myObject."</span> + myKey + <span class="string">";"</span>);</div></pre></td></tr></table></figure>

<p>而不是这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myValue = myObject[myKey];</div></pre></td></tr></table></figure>

<p>使用eval形式的代码会更加难以阅读。这种形式会使得性能显著降低，因为它须运行编译器，但也许是为了执行一个微不足道的赋值语句。它也会让JSLint失效，因此该工具检测问题的能力也会降低。</p>
<p>eval函数还降低了你应用的安全性，因为它给被求值的语句赋予了太多的能力。</p>
<p>Function构造函数是eval的另一种形式。所以它也应该避免使用。</p>
<p>浏览器提供的setInterval &amp; setTimeout函数，它们能接受字符串参数和函数参数。当传递的是字符串参数时，setInterval &amp; setTimeout会像eval那样去处理，字符串参数形式也应该被避免。</p>
<p><strong>4. continue语句</strong></p>
<p>continue语句跳到循环的顶部，作者发现一段代码通过重构移除continue语句之后，性能都会得到改善。</p>
<p><strong>5. switch贯穿（不懂，P125）</strong></p>
<p>switch语句，除非你明确的中断流程，否则每次条件判断后会贯穿到下一个case条件。</p>
<p><strong>6. 缺少块的语句</strong></p>
<p>If、while、do or for语句可以接受一个括在花括号中的代码块，也可以接受单行语句。单行形式的语句是另一种带刺的玫瑰，它带来的好处是可以节约两个字节，但这是不是一个好处值的商榷。它模糊了程序的结构，使得在随后的操作代码中可能很容易插入错误。e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ok)</div><div class="line">t = <span class="literal">true</span>;</div></pre></td></tr></table></figure>

<p>可能变成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ok)</div><div class="line">    t = <span class="literal">true</span>;</div><div class="line">    advance();</div></pre></td></tr></table></figure>

<p>它看起来像是要这样: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ok) {</div><div class="line">    t = <span class="literal">true</span>;</div><div class="line">    advance();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是实际执行是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ok) {</div><div class="line">    t = <span class="literal">true</span>;</div><div class="line">}</div><div class="line">advance();</div></pre></td></tr></table></figure>

<p>严格规范并使用代码块会使得代码更容易理解。</p>
<p><strong>7. ++ &amp; —</strong></p>
<p>递增和递减运算符使得程序员可以用非常简洁的风格去编码，而事实上，这两种运算符容易促成一种不谨慎的编码风格，大多数的缓冲区溢出错误所造成的安全漏洞，都是由于像这样的编码导致的。</p>
<p>作者认为使用 ++ &amp; —时，代码往往变得过于紧密，复杂和隐晦。因此，作为一条原则，不再使用它们，那样会让代码风格变得更简洁（<strong>不明白</strong>）。</p>
<p><strong>8. 位运算符</strong></p>
<p>JavaScript有着与java相同的一套运算符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&    and 按位与</div><div class="line">|    or  按位或</div><div class="line">^    xor 按位异或</div><div class="line">！   not 按位非</div><div class="line">&gt;&gt;   带符号右移</div><div class="line">&gt;&gt;&gt;  无符号的（用<span class="number">0</span>补足的右移）</div><div class="line">&lt;&lt;   左移</div></pre></td></tr></table></figure>

<p>在java里位运算符处理的是整数。JavaScript没有整数类型，它只有双精度的浮点数，因此，位运算符先将它们的数字运算先转换成整数，接着执行运算，然后再转换回去。</p>
<p>在大多数语言中，这些位运算符接近于硬件处理而非常快，但在JavaScript中，它们非但不是硬件处理，而且非常慢。JavaScript很少被用来执行位操作。</p>
<p><strong>9. function语句对比函数表达式</strong></p>
<p>JavaScript既有function语句，同时也有函数表达式。这是令人困惑的，因为它们看起来好像就是相同的。一个function语句就是其值为一个函数的var语句的速记形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="title">foo</span></span>(){}</div></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var foo = <span class="function"><span class="title">function</span></span>(){}</div></pre></td></tr></table></figure>

<p>要学好这门语言，理解函数就是数值是很重要的。</p>
<p>function语句在解析时会发生被提升的情况。这意味着不管函数放在哪里，它会被移动到被定义时所在作用域的顶层。这放宽了函数必须先声明后使用的要求，而我认为这会导致混乱。</p>
<p>在 if 语句中使用 function 语句也是被禁止的。结果表明大多数浏览器都允许在 if 语句中使用 function 语句，但它们在解析时的处理上各不相同。这就造成了可移植性的问题。</p>
<p>一个语句不能以一个函数表达式开头，因为官方的语法假定以单词 function 开头的语句是一个 function 语句。解决办法就是把函数表达式扩在一个圆括号之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="title">function</span></span>(){</div><div class="line">    var hidden_variable;</div><div class="line">    console.log(hidden_variable); //undefined</div><div class="line">    console.log(this);            //window</div><div class="line">    //这个函数可能对环境有一些影响，但不会引入新的全局变量</div><div class="line">})();</div></pre></td></tr></table></figure>

<p><strong>10. 类型的包装对象</strong></p>
<p>JavaScript有一套类型的包装对象。e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Boolean(<span class="literal">false</span>)</div></pre></td></tr></table></figure>



<p>会返回一个对象，该对象有一个valueof方法会返回被包装的值。这其实完全没有必要，并且有时还令人困惑。不要使用new Boolean、new Number、new String。也请避免使用new Object、new Array.</p>
<p><strong>11. new</strong></p>
<p>JavaScript 的 new 运算符创建一个继承于其运算数的原型的对象，然后调用该运算数，把新创建的对象绑定给this，这给运算数（它应该是一个构造器函数）一个机会在返回在返回给请求者之前去自定义新创建的对象。</p>
<p>如果忘记使用new运算符，你所得到的就是普通的函数调用，并且this被绑定到全局对象，而不是新创建的对象。那意味着当你的函数尝试去初始化新成员元素时它将会污染全局对象。</p>
<p>按照惯列，打算与new运算符结合使用的函数应该命名为说字母大写形式，并且首字母大写的形式应该只用来命名那些构造器函数。这个约定给我们提供了一个视觉线索，以帮助我们发现那些JavaScript语言自身经常忽略但却会带来昂贵代价的错误。</p>
<p>更好的应对策略就是根本不使用new。</p>
<p><strong>12. void</strong></p>
<p>在很多语言中，void是一种类型，表示没有值。而在JavaScript里，void是一个运算符，它接受一个运算数并返回undefined, 这并没有什么用，反而让人感到很困惑，应该避免使用。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/19/essence-9-chicken-ribs/" data-id="mxwwwec5spa2gymj" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-chicken-ribs/">essence-chicken-ribs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-5-5-string-fn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/16/essence-5-5-string-fn/" class="article-date">
  <time datetime="2015-10-16T05:52:13.000Z" itemprop="datePublished">Oct 16 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/16/essence-5-5-string-fn/">essence-string-fn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 ——函数方法。</p>
<p>Javascript包含了一套小型的可用在标准类型上的标准方法集。</p>
<p><strong>1. string.charAt(pos)</strong></p>
<p>charAt方法返回在string中pos位置处的字符。如果pos小于0或大于等于字符串的长度string.length, 它会返回空字符串。JavaScript没有字符类型。这个方法的返回结果过是一个字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var name = <span class="string">"Curly"</span>;</div><div class="line">var initial = name.charAt(<span class="number">0</span>); //C</div></pre></td></tr></table></figure>



<p>charAt可以像这样实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String.method(<span class="string">"charAt"</span>, function(pos){</div><div class="line">    <span class="keyword">return</span> this.slice(pos, pos+<span class="number">1</span>)</div><div class="line">});</div></pre></td></tr></table></figure>



<p><strong>2. string.charCodeAt(pos)</strong></p>
<p>charCodeAt方法和charAt方法类似。它返回不是一个字符串，而是这个字符的字符码，字符码是整数形式。如果pos小于0或大于等于字符串的长度string.length, 返回NaN。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var name = <span class="string">"Curly"</span>;</div><div class="line">var initial = name.charCodeAt(<span class="number">0</span>); //<span class="number">67</span></div></pre></td></tr></table></figure>



<p><strong>3. string.concat(string…)</strong></p>
<p>concat方法把其他字符串连接在一起来构造一个新的字符串。很少使用，因为用+运算符更方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var s = <span class="string">'C'</span>.concat(<span class="string">'a'</span>, <span class="string">'t'</span>); //<span class="string">"Cat"</span></div></pre></td></tr></table></figure>



<p><strong>4. string.indexOf(searchString，position)</strong></p>
<p>indexOf方法在string内查找另一个字符串searchString。如果它被找到，返回第一个匹配字符的位置，否则返回-1.可选参数position可设置从string的某个指定位置开始查找。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'Mississippi'</span>;</div><div class="line">var p = text.indexOf(<span class="string">'ss'</span>); //<span class="number">2</span></div><div class="line">p = text.indexOf(<span class="string">'ss'</span>, <span class="number">3</span>);  //<span class="number">5</span></div><div class="line">p = text.indexOf(<span class="string">'ss'</span>, <span class="number">6</span>);  //-<span class="number">1</span></div></pre></td></tr></table></figure>



<p><strong>5. string.lastIndexOf(searchString，position)</strong></p>
<p>lastIndexOf方法和index方法类似。只不过它是从该字符串的末尾开始查找而不是从开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'Mississippi'</span>;</div><div class="line">var p = text.lastIndexOf(<span class="string">'ss'</span>); //<span class="number">5</span></div><div class="line">p = text.lastIndexOf(<span class="string">'ss'</span>, <span class="number">3</span>);  //<span class="number">2</span></div><div class="line">p = text.lastIndexOf(<span class="string">'ss'</span>, <span class="number">6</span>);  //<span class="number">5</span></div></pre></td></tr></table></figure>



<p><strong>6. string.localCompare(that)</strong></p>
<p>localCompare方法比较两个字符串。如果string比字符串that小，那么结果为负数。如果它们相等，那么结果为0.类似于array.sort()比较函数的约定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var m = [<span class="string">'AAA'</span>, <span class="string">'A'</span>, <span class="string">'aa'</span>, <span class="string">'a'</span>, <span class="string">'Aa'</span>, <span class="string">'aaa'</span>];</div><div class="line">m.sort(function(a, b){</div><div class="line">    <span class="keyword">return</span> a.localeCompare(b);</div><div class="line">}); </div><div class="line">//[<span class="string">"a"</span>, <span class="string">"A"</span>, <span class="string">"aa"</span>, <span class="string">"Aa"</span>, <span class="string">"aaa"</span>, <span class="string">"AAA"</span>]</div></pre></td></tr></table></figure>



<p><strong>7. string.match(regexp)</strong></p>
<p>match方法让字符串和一个正则表达式匹配。它根据g标识来决定如何进行匹配。那么调用string.match(regexp)的结果与regexp.exec(string)的结果相同。如果带有g标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'&lt;html&gt;&lt;body bgcolor=linen&gt;&lt;p&gt;This is &lt;b&gt;body&lt;\/b&gt;!&lt;\/p&gt;&lt;\/body&gt;&lt;\/html&gt;'</span>;</div><div class="line">var tags = /[^&lt;&gt;]+|&lt;(\/?)([A-Za-z]+)([^&lt;&gt;]*)&gt;/g;</div><div class="line">var a, i;</div><div class="line">a = text.match(tags);</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; a.length; i++){</div><div class="line">    document.writeln((<span class="string">'// ['</span> + i + <span class="string">'] '</span> + a[i]).entityify());  //entityify 报错称没有这个方法</div><div class="line">}</div></pre></td></tr></table></figure>



<p><strong>8. string.replace(searchValue, replaceValue)</strong></p>
<p>replace方法对string进行查找和替换操作，并返回一个新的字符串。searchValue可以是一个字符串或一个正则表达式对象。如果它是一个字符串，searchValue只会在第1此出现的地方被替换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var result = <span class="string">"mother_in_law"</span>.replace(<span class="string">'_'</span>, <span class="string">'-'</span>);    //<span class="string">"mother-in_law"</span></div></pre></td></tr></table></figure>

<p>这或许不是我们想要的结果，如果searchValue是一个正则表达式并且带有g标识，它会替换所有的匹配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var result = <span class="string">"mother_in_law"</span>.replace(/\_/g, <span class="string">'-'</span>);  //<span class="string">"mother-in-law"</span></div></pre></td></tr></table></figure>

<p>replaceValue可以是一个字符串或一个函数。如果是一个字符串，字符$拥有特别的含义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var oldareacode = /\((\d{<span class="number">3</span>})\)/g;</div><div class="line"></div><div class="line">var p = <span class="string">'(555)666-1212'</span>.replace(oldareacode, <span class="string">'$$'</span>); //<span class="string">"<span class="variable">$666</span>-1212"</span></div><div class="line"></div><div class="line">var p = <span class="string">'(555)666-1212'</span>.replace(oldareacode, <span class="string">'$1-'</span>); //<span class="string">"555-666-1212"</span></div><div class="line">var p = <span class="string">'(555)666-1212'</span>.replace(oldareacode, <span class="string">"<span class="variable">$1</span>'"</span>); //<span class="string">"555'666-1212"</span></div><div class="line"></div><div class="line">var p = <span class="string">'(555)666-1212'</span>.replace(oldareacode, <span class="string">"$`"</span>);  //<span class="string">"666-1212"</span></div><div class="line">var p = <span class="string">'(555)666-1212'</span>.replace(oldareacode, <span class="string">"$'"</span>); //<span class="string">"666-1212666-1212"</span></div></pre></td></tr></table></figure>

<p>. $$， 替换对象是：$$<br>. $&amp;， 替换对象是：整个匹配的文本<br>. $number，替换对象是：分组捕获的文本<br>. $`，替换对象是：匹配之前的文本<br>. $’，替换对象是：匹配之后的文本</p>
<p>如果replaceValue是一个函数，那么每遇到一次匹配函数就会被调用一次，而该函数返回的字符串会被用做替换文本。传递给这个函数的第1个参数是整个被匹配的文本，第2个参数是分组1捕获的文本，再下一个参数是分组2捕获的文本，以此类推。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">String.method(<span class="string">'entityify'</span>, <span class="function"><span class="title">function</span></span>(){</div><div class="line">    var character = {</div><div class="line">        <span class="string">'&lt;'</span>: <span class="string">'&lt;'</span>,</div><div class="line">        <span class="string">'&gt;'</span>: <span class="string">'&gt;'</span>,</div><div class="line">        <span class="string">'&'</span>: <span class="string">'&amp;'</span>,</div><div class="line">        <span class="string">'"'</span>: <span class="string">'&quot;'</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="title">function</span></span>(){</div><div class="line">        <span class="keyword">return</span> this.replace(/[&lt;&gt;&<span class="string">"]/g, function(c){</span></div><div class="line">            return character[c];</div><div class="line">        });</div><div class="line">    };</div><div class="line">}());</div><div class="line"></div><div class="line">alert("&lt;&&gt;<span class="string">".entityify()); //&lt;&amp;&gt;</span></div></pre></td></tr></table></figure>

<p><strong>9. string.search(regexp)</strong></p>
<p>search方法和indexof方法类似，只是它接受一个正则表达式对象作为参数而不是一个字符串。如果找到匹配，它返回第一个匹配的首字符位置，如果没有找到匹配，则返回-1.此方法会忽略g标识，且没有position参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'and in it he says "Any damn fool could"'</span>;</div><div class="line">var pos = text.search(/[<span class="string">"']/);   //pos是18</span></div></pre></td></tr></table></figure>

<p><strong>10. string.slice(start, end)</strong></p>
<p>slice方法复制string的一部分来构造一个新的字符串。如果start参数是负数，它将与string.length相加。end参数是可选的，且默认值是string.length。如果end参数是负数，那么它将与string.length相加。end参数等于你要取的蕞后一个字符的位置加1.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'and in it he says "Any damn fool could"'</span>;</div><div class="line">var a = text.slice(<span class="number">18</span>);  //<span class="string">""</span>Any damn fool could<span class="string">""</span></div><div class="line">var b = text.slice(<span class="number">0</span>, <span class="number">3</span>); //<span class="string">"and"</span></div><div class="line">var c = text.slice(-<span class="number">6</span>); //<span class="string">"could"</span><span class="string">"</span></div><div class="line">var d = text.slice(19, 32); //"Any damn fool<span class="string">"</span></div></pre></td></tr></table></figure>

<p><strong>11. string.split(separator, limit)</strong></p>
<p>split方法把string分割成片段来创建一个字符串数组。可选参数limit可以限制被分割的片段数量。separator参数可以是一个字符串或是一个正则表达式。</p>
<p>如果separator是一个空字符， 会返回一个单字符的数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var digits = <span class="string">'0123456789'</span>;</div><div class="line">var a =  digits.split(<span class="string">''</span>, <span class="number">5</span>); //[<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>]</div></pre></td></tr></table></figure>

<p>否则，此方法会在string中查找所有separator出现的地方。分隔符两边的每个单元文本都会被复制到该数组中。此方法会忽略g标识。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ip = <span class="string">'192.168.1.0'</span>;</div><div class="line">var b =  ip.split(<span class="string">'.'</span>);  //[<span class="string">"192"</span>, <span class="string">"168"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>]</div><div class="line"></div><div class="line">var c = <span class="string">'|a|b|c|'</span>;</div><div class="line">var d = c.split(<span class="string">'|'</span>);   //[<span class="string">""</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">""</span>]</div><div class="line"></div><div class="line">var text = <span class="string">'last, first, middle'</span>;</div><div class="line">var e = text.split(/\s*,\s*/);   //[<span class="string">"last"</span>, <span class="string">"first"</span>, <span class="string">"middle"</span>]</div></pre></td></tr></table></figure>

<p>有些特列需要注意，来自分组捕获的文本会被包含在被分割后的数组中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var text = <span class="string">'last, first, middle'</span>;</div><div class="line">var e = text.split(/\s*(,)\s*/);  //[<span class="string">"last"</span>, <span class="string">","</span>, <span class="string">"first"</span>, <span class="string">","</span>, <span class="string">"middle"</span>]</div></pre></td></tr></table></figure>

<p>有separator是一个正则表达式时，有一些javascript的实现在输出数组中会排除掉空字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f = <span class="string">'|a|b|c|'</span>.split(/\|/);</div><div class="line">//在主流浏览器中输出是[<span class="string">""</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">""</span>]</div><div class="line">//IE8以下的浏览器输出是[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]，会把空字符去掉，ie9已经修复这个bug</div></pre></td></tr></table></figure>

<p><strong>12. string.substring(start, end)</strong></p>
<p>substring方法和slice方法一样，只是它不能处理负数参数。没有任何理由去使用substring方法，请使用slice替代。</p>
<p><strong>13. string.toLocaleLowerCase()</strong></p>
<p>toLocaleLowerCase方法返回一个新的字符串，它使用本地化的规则把这个string中的所有字母转换成小写格式。主要用在土耳其语中。</p>
<p><strong>14. string.toLocaleUpperCase()</strong></p>
<p>toLocaleUpperCase方法返回一个新的字符串，它使用本地化的规则把这个string中的所有字母转换成大写格式。主要用在土耳其语中。</p>
<p><strong>15. string.toLowerCase()</strong></p>
<p>toLowerCase方法返回一个新的字符串，这个string中的所有字母被转换成小写格式。</p>
<p><strong>16. string.toUpperCase()</strong></p>
<p>toUpperCase方法返回一个新的字符串，这个string中的所有字母被转换成大写格式。</p>
<p><strong>17. String.fromCharCode(char…)</strong></p>
<p>String.fromCharCode函数根据一串数字编码返回一个字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = String.fromCharCode(<span class="number">67</span>,<span class="number">97</span>,<span class="number">116</span>);  //<span class="string">"Cat"</span></div></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/16/essence-5-5-string-fn/" data-id="ttaa8n9yqsl4k9ey" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-string-fn/">essence-string-fn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essence-5-4-object-fn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/16/essence-5-4-object-fn/" class="article-date">
  <time datetime="2015-10-16T03:03:57.000Z" itemprop="datePublished">Oct 16 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Essence/">Essence</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/16/essence-5-4-object-fn/">essence-object-fn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读JavaScript语言精粹一书 ——函数方法。</p>
<p>Javascript包含了一套小型的可用在标准类型上的标准方法集。</p>
<p><strong>1. object.hasOwnProperty(name)</strong></p>
<p>如果这个对象包含一个名为name的属性，那么hasOwnProperty方法返回true。原型链中的同名属性是不会被检查的。这个方法对name是’hasOwnProperty’时不起作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = {member: <span class="literal">true</span>};</div><div class="line">var b = Object.create(a);</div><div class="line">var t = a.hasOwnProperty(<span class="string">'member'</span>);  //<span class="literal">true</span></div><div class="line">var u = b.hasOwnProperty(<span class="string">'member'</span>);  //<span class="literal">false</span></div><div class="line">var v = b.member;                    //<span class="literal">true</span></div></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/16/essence-5-4-object-fn/" data-id="s1ylm4skl1xw70l1" class="article-share-link" data-share="baidu">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/essence-object-fn/">essence-object-fn</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/archives/2015/page/2/">2</a><a class="page-number" href="/archives/2015/page/3/">3</a><a class="page-number" href="/archives/2015/page/4/">4</a><a class="extend next" rel="next" href="/archives/2015/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Html5-form-attr/" style="font-size: 20.00px;">Html5 form attr</a><a href="/tags/Ubuntu常用命令/" style="font-size: 20.00px;">Ubuntu常用命令</a><a href="/tags/app-market-cms-总结/" style="font-size: 20.00px;">app-market-cms 总结</a><a href="/tags/app-market-csm-总结/" style="font-size: 10.00px;">app-market-csm 总结</a><a href="/tags/arguments/" style="font-size: 20.00px;">arguments</a><a href="/tags/backboneTrap/" style="font-size: 20.00px;">backboneTrap</a><a href="/tags/call/" style="font-size: 20.00px;">call()</a><a href="/tags/commonly-used-in-work-javascript/" style="font-size: 20.00px;">commonly-used-in-work-javascript</a><a href="/tags/essence-arrays/" style="font-size: 20.00px;">essence-arrays</a><a href="/tags/essence-arrays-fn/" style="font-size: 20.00px;">essence-arrays-fn</a><a href="/tags/essence-chicken-ribs/" style="font-size: 20.00px;">essence-chicken-ribs</a><a href="/tags/essence-code-style/" style="font-size: 20.00px;">essence-code-style</a><a href="/tags/essence-function/" style="font-size: 20.00px;">essence-function</a><a href="/tags/essence-function-fn/" style="font-size: 20.00px;">essence-function-fn</a><a href="/tags/essence-graceful-characteristic/" style="font-size: 20.00px;">essence-graceful-characteristic</a><a href="/tags/essence-inheritance/" style="font-size: 20.00px;">essence-inheritance</a><a href="/tags/essence-loose/" style="font-size: 20.00px;">essence-loose</a><a href="/tags/essence-number-fn/" style="font-size: 20.00px;">essence-number-fn</a><a href="/tags/essence-object/" style="font-size: 20.00px;">essence-object</a><a href="/tags/essence-object-fn/" style="font-size: 20.00px;">essence-object-fn</a><a href="/tags/essence-string-fn/" style="font-size: 20.00px;">essence-string-fn</a><a href="/tags/event/" style="font-size: 20.00px;">event</a><a href="/tags/gitTrap/" style="font-size: 20.00px;">gitTrap</a><a href="/tags/hexo/" style="font-size: 20.00px;">hexo</a><a href="/tags/html5属性/" style="font-size: 20.00px;">html5属性</a><a href="/tags/http-summary/" style="font-size: 20.00px;">http-summary</a><a href="/tags/http-url-resource/" style="font-size: 20.00px;">http-url&resource</a><a href="/tags/js元素操作/" style="font-size: 20.00px;">js元素操作</a><a href="/tags/publickey-ssh/" style="font-size: 10.00px;">publickey, ssh</a><a href="/tags/requireJsTrap/" style="font-size: 20.00px;">requireJsTrap</a><a href="/tags/safePhone-总结/" style="font-size: 20.00px;">safePhone 总结</a><a href="/tags/setTimeout-setInterval/" style="font-size: 20.00px;">setTimeout(), setInterval()</a><a href="/tags/the-essence-of-the-JavaScript/" style="font-size: 10.00px;">the-essence-of-the-JavaScript</a><a href="/tags/top命令/" style="font-size: 20.00px;">top命令</a><a href="/tags/webstorm快捷键/" style="font-size: 20.00px;">webstorm快捷键</a><a href="/tags/函数节流/" style="font-size: 20.00px;">函数节流</a><a href="/tags/常用regExp/" style="font-size: 20.00px;">常用regExp</a><a href="/tags/开发中的坑洼沟/" style="font-size: 10.00px;">开发中的坑洼沟</a><a href="/tags/日记2015-09-15/" style="font-size: 10.00px;">日记2015-09-15</a><a href="/tags/重绘-重排/" style="font-size: 20.00px;">重绘, 重排</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Css/">Css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Essence/">Essence</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Html5/">Html5</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Http/">Http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Js/">Js</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Liunx/">Liunx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/28/http-2-url-resource/">http-2-url&amp;resource</a>
          </li>
        
          <li>
            <a href="/2015/10/27/http-1-summary/">http-1-summary</a>
          </li>
        
          <li>
            <a href="/2015/10/26/essence-11-regexp/">essence-11-Regexp</a>
          </li>
        
          <li>
            <a href="/2015/10/21/essence-10-JSON/">essence-10-JSON</a>
          </li>
        
          <li>
            <a href="/2015/10/19/essence-6-code-style/">essence-code-style</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
          <li>
            <a href="http://selayou9527.github.io" target="_blank">色拉油</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Qianqian Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>window._bd_share_config={"common":{},"share":{"bdCustomStyle":"/css/bdshare.css"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>


</div>
</body>
</html>
